Below are the files created for a Vite + React project: socket initialization (VITE\_SOCKET\_URL), API wrapper, message/notification services, and two UI components (Messages and Notifications).

---

## Files & code

### `src/services/api.js`

```js
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL;

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add a request interceptor to attach the JWT token automatically
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token'); // retrieve JWT from localStorage
    if (token) {
      config.headers.Authorization = `Bearer ${token}`; // set Authorization header
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default api;
```

---

### `src/services/socket.js`

```js
import { io } from 'socket.io-client';
import { useEffect } from 'react';

const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || 'http://localhost:5000';
let socket = null;

/**
 * Initialize socket once. If token is available it will be sent via auth.
 * Call this early in your app (e.g. App.jsx) or in components that need sockets.
 */
export const initSocket = (token) => {
  if (socket) return socket;

  socket = io(SOCKET_URL, {
    auth: token ? { token } : undefined,
    transports: ['websocket'],
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
  });

  // Optional global listeners for logging/debugging
  socket.on('connect', () => {
    // console.debug('Socket connected', socket.id);
  });
  socket.on('disconnect', (reason) => {
    // console.debug('Socket disconnected', reason);
  });

  return socket;
};

export const getSocket = () => socket;

export const subscribe = (event, cb) => {
  if (!socket) return () => {};
  socket.on(event, cb);
  return () => socket.off(event, cb);
};

export const emit = (event, payload, ack) => {
  if (!socket) return;
  socket.emit(event, payload, ack);
};

export const disconnectSocket = () => {
  if (!socket) return;
  socket.disconnect();
  socket = null;
};

/**
 * React hook: pass an object of { eventName: handler }
 * Example: useSocket({ 'message': onMessage })
 */
export const useSocket = (events = {}) => {
  useEffect(() => {
    // ensure socket exists and uses current token
    const token = localStorage.getItem('token');
    initSocket(token);

    const removers = [];
    Object.entries(events).forEach(([evt, handler]) => {
      if (!handler) return;
      socket.on(evt, handler);
      removers.push(() => socket.off(evt, handler));
    });

    return () => removers.forEach((fn) => fn());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, Object.keys(events).map((k) => k).join(','));
};
```

---

### `src/services/messages.js`

```js

```

---

### `src/services/notifications.js`

```js

```

---

### `src/components/Messages.jsx`

```jsx
```

---

### `src/components/Notifications.jsx`

```jsx
import React, { useEffect, useState } from 'react';
import { getNotifications, markAsRead, markAllRead } from '../services/notifications';
import { initSocket, subscribe } from '../services/socket';

export default function Notifications() {
  const [open, setOpen] = useState(false);
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    getNotifications({ page: 0, limit: 20 })
      .then((data) => setNotifications(data.notifications || data || []))
      .finally(() => setLoading(false));
  }, []);

  useEffect(() => {
    initSocket(localStorage.getItem('token'));
    const off = subscribe('notification', (n) => {
      if (!n) return;
      setNotifications((prev) => [n, ...prev]);
    });

    return () => off();
  }, []);

  const unreadCount = notifications.filter((n) => !n.read).length;

  const handleMarkAsRead = async (id) => {
    try {
      await markAsRead(id);
      setNotifications((prev) => prev.map((n) => (n.id === id ? { ...n, read: true } : n)));
    } catch (e) {
      console.error(e);
    }
  };

  const handleMarkAll = async () => {
    try {
      await markAllRead();
      setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
    } catch (e) {
      console.error(e);
    }
  };

  return (
    <div className="relative inline-block text-left">
      <button onClick={() => setOpen((s) => !s)} className="relative px-3 py-2">
        Notifications
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 inline-flex items-center justify-center px-2 py-1 text-xs font-bold rounded-full bg-red-600 text-white">{unreadCount}</span>
        )}
      </button>

      {open && (
        <div className="absolute right-0 mt-2 w-80 bg-white border rounded shadow-lg z-50">
          <div className="p-2 border-b flex justify-between items-center">
            <span className="font-semibold">Notifications</span>
            <button onClick={handleMarkAll} className="text-sm text-gray-500">Mark all read</button>
          </div>

          <div className="max-h-64 overflow-y-auto p-2">
            {loading ? (
              <div className="text-sm text-gray-500">Loading...</div>
            ) : notifications.length === 0 ? (
              <div className="text-sm text-gray-500">No notifications</div>
            ) : (
              notifications.map((n) => (
                <div key={n.id} className={`p-2 mb-1 rounded ${n.read ? 'bg-gray-50' : 'bg-white'}`}>
                  <div className="text-sm">{n.title || n.message}</div>
                  <div className="text-xs text-gray-400 flex items-center justify-between">
                    <span>{new Date(n.createdAt).toLocaleString()}</span>
                    {!n.read && (
                      <button onClick={() => handleMarkAsRead(n.id)} className="text-xs text-blue-600 ml-2">Mark read</button>
                    )}
                  </div>
                </div>
```
